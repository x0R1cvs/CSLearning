/*
THIS IS A GENERATED/BUNDLED FILE BY ROLLUP
if you want to view the source visit the plugins github repository
*/

'use strict';

var obsidian = require('obsidian');

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

class Log {
    constructor() {
        this.warn = console.warn;
    }
    setUp(plugin) {
        this.isDev = plugin.manifest.name.toLowerCase().contains('canary');
        if (this.isDev) {
            this.info = console.info;
        }
    }
    // eslint-disable-next-line
    info(..._) {
        // empty function in non dev envs
    }
}
const log = new Log();

const DEFAULT_WIDTH = 500;
const DEFAULT_HEIGHT = 500;
const DEFAULT_BUFFER = 100;
// recursive function that calls itself to create a list of nodes and edges
// to add to the canvas
// Some notes
// - it only allows unique notes
// - it priotises notes that have a lower depth overwriting notes that already exist
function createChildren(path, resolvedLinks, depth, canvasHashes = [{}, {}], 
// the column the path is in
colNumber = 0, 
// used to keep track of how many items are in each column
colCount = {}) {
    log.info(path, depth, colNumber);
    if (!colCount[colNumber]) {
        colCount[colNumber] = 0;
    }
    let [returnedNodes, returnedEdges] = canvasHashes;
    const fileLinks = Object.keys(resolvedLinks[path] || {});
    // if returnedNodes is empty we can assume this is the first round and we add
    // it to the returnedNodes hash
    let topLevelAdded = false;
    if (Object.keys(returnedNodes).length === 0) {
        returnedNodes[path] = {
            id: path,
            width: DEFAULT_WIDTH,
            height: DEFAULT_HEIGHT,
            y: 0,
            x: 0,
            type: 'file',
            file: path,
            color: '1',
        };
        topLevelAdded = true;
    }
    // we use this to do a comparison to make a decision about if the level
    // of the current node is lower then the previous version of the node (if exists)
    const currentLevelXValue = (DEFAULT_WIDTH + 500) * (colNumber + 1);
    for (let i = 0; i < fileLinks.length; i++) {
        const link = fileLinks[i];
        log.info(Array.from(new Array(colNumber))
            .map(() => '--')
            .join(''), colNumber, link);
        const edgeId = `${path}-${link}`;
        returnedEdges[edgeId] = {
            id: edgeId,
            fromSide: 'right',
            toSide: 'left',
            fromNode: path,
            toNode: link,
        };
        // checks that node doesn't already exist and if it does it's x (using as a
        // reresentation of level) is higher then the new node then we override it.
        // we want to prioritise notes closer to the source
        if (!returnedNodes[link] || returnedNodes[link].x > currentLevelXValue) {
            returnedNodes[link] = {
                id: link,
                width: DEFAULT_WIDTH,
                height: DEFAULT_HEIGHT,
                x: currentLevelXValue,
                y: colCount[colNumber] * (DEFAULT_HEIGHT + DEFAULT_BUFFER),
                type: 'file',
                file: link,
            };
            colCount[colNumber] = colCount[colNumber] + 1;
        }
        if (colNumber < depth) {
            const prevNodeCount = Object.keys(returnedNodes).length;
            const nextDepth = colNumber + 1;
            // before children get added we need to save the start point for this node so we can
            // easily set how its postioned amongst it's children
            const nodeYStartingPosition = (colCount[nextDepth] || 0) * (DEFAULT_HEIGHT + DEFAULT_BUFFER);
            const [childNodes, childEdges] = createChildren(link, resolvedLinks, depth, [returnedNodes, returnedEdges], nextDepth, colCount);
            const newChildrenAdded = Object.keys(childNodes).length - prevNodeCount;
            if (newChildrenAdded > 0) {
                childNodes[link].y =
                    nodeYStartingPosition +
                        calculateYPositionFromNumberOfChildren(newChildrenAdded);
            }
            else {
                // if it has no children we add a count to the next col to give it a buffer so the
                // next sibblings children doesn't take up the space
                childNodes[link].y =
                    colCount[nextDepth] * (DEFAULT_HEIGHT + DEFAULT_BUFFER);
                colCount[nextDepth] = colCount[nextDepth] + 1;
            }
            returnedNodes = Object.assign(Object.assign({}, returnedNodes), childNodes);
            returnedEdges = Object.assign(Object.assign({}, returnedEdges), childEdges);
        }
    }
    // as we added the top level node earlier we now have to position it right we get the length of
    // of the children in the highest col
    if (topLevelAdded) {
        for (let i = depth; i >= 0; i--) {
            const maxRowCount = colCount[i];
            if (maxRowCount) {
                returnedNodes[path].y =
                    calculateYPositionFromNumberOfChildren(maxRowCount);
                break;
            }
        }
    }
    return [returnedNodes, returnedEdges];
}
// TODO use this to improve orign function
function createIncomingChildren(path, resolvedLinks, canvasHashes = [{}, {}]) {
    const [returnedNodes, returnedEdges] = canvasHashes;
    if (!returnedNodes[path]) {
        log.warn('createIncomingChildren: path not in canvasHashes');
        return canvasHashes;
    }
    const fileLinks = Object.keys(resolvedLinks[path] || {}).filter((link) => !returnedNodes[link]);
    const baseY = returnedNodes[path].y;
    const yStart = baseY +
        DEFAULT_HEIGHT / 2 -
        ((fileLinks.length / 2) * DEFAULT_HEIGHT +
            ((fileLinks.length - 1) / 2) * DEFAULT_BUFFER);
    for (let i = 0; i < fileLinks.length; i++) {
        const link = fileLinks[i];
        const edgeId = `${path}-${link}`;
        returnedEdges[edgeId] = {
            id: edgeId,
            fromSide: 'right',
            toSide: 'left',
            fromNode: link,
            toNode: path,
        };
        returnedNodes[link] = {
            id: link,
            width: DEFAULT_WIDTH,
            height: DEFAULT_HEIGHT,
            x: 0 - (DEFAULT_WIDTH + 500),
            y: yStart + i * (DEFAULT_HEIGHT + DEFAULT_BUFFER),
            type: 'file',
            file: link,
        };
    }
    return [returnedNodes, returnedEdges];
}
const calculateYPositionFromNumberOfChildren = (childrenCount) => (DEFAULT_HEIGHT * childrenCount + DEFAULT_BUFFER * (childrenCount - 1)) / 2 -
    DEFAULT_HEIGHT / 2;
function createCanvasFromFile(activeFile, resolvedLinks, doesFileExist, createFile, openFile, location) {
    return __awaiter(this, void 0, void 0, function* () {
        const { path: filePath, basename: fileName } = activeFile;
        const resolvedIncomingLinks = buildResolvedIncomingLinks(resolvedLinks);
        // TODO: create a combined resolved links so we're not passing two different ones
        // to the same func
        const [outgoingNodes, outgoingEdges] = createChildren(filePath, resolvedLinks, 1);
        const [incomingNodes, incomingEdges] = createIncomingChildren(filePath, resolvedIncomingLinks, [outgoingNodes, outgoingEdges]);
        const nodes = Object.values(incomingNodes);
        const edges = Object.values(incomingEdges);
        const canvas = { nodes, edges };
        log.info(canvas);
        const path = getFileName(location ? `${location}/${fileName}.canvas` : `${fileName}.canvas`, doesFileExist);
        if (!path) {
            throw `unable to save: ${fileName}`;
        }
        const result = yield createFile(path, JSON.stringify(canvas, null, 2));
        openFile(result);
        log.info(result);
        return result;
    });
}
// buildResolvedIncomingLinks takes the outgoingResolvedLinks and flips it to
// incoming links where the top level key is the path and the record value is a
// is a record with the keys being other paths that point to it. The number value is not used
// and set to one
const buildResolvedIncomingLinks = (resolvedLinks) => {
    const resolvedIncomingLinks = {};
    Object.entries(resolvedLinks).forEach(([linker, destination]) => {
        Object.keys(destination).forEach((path) => {
            if (!resolvedIncomingLinks[path]) {
                resolvedIncomingLinks[path] = {};
            }
            resolvedIncomingLinks[path][linker] = 1;
        });
    });
    return resolvedIncomingLinks;
};
// getFileName looks for a safe file name to use and returns it.
// will take the path and add -n to the end until I finds one that doesn't
// exist
const getFileName = (path, doesFileExist) => {
    if (!doesFileExist(path)) {
        return path;
    }
    const limit = 50;
    const [name, extention] = path.split('.');
    for (let i = 0; i < limit; i++) {
        const newPath = `${name}-${i}.${extention}`;
        log.info(newPath);
        if (!doesFileExist(newPath)) {
            return newPath;
        }
    }
    return null;
};

var Location;
(function (Location) {
    Location[Location["VaultFolder"] = 0] = "VaultFolder";
    Location[Location["SameFolder"] = 1] = "SameFolder";
    Location[Location["SpecifiedFolder"] = 2] = "SpecifiedFolder";
})(Location || (Location = {}));
class LinkExploderPluginSettingTab extends obsidian.PluginSettingTab {
    constructor(app, plugin) {
        super(app, plugin);
        this.plugin = plugin;
    }
    display() {
        const { containerEl } = this;
        containerEl.empty();
        containerEl.createEl('h2', { text: 'Link Exploder Settings' });
        new obsidian.Setting(containerEl)
            .setName('Default location for new canvas files')
            .addDropdown((dropDown) => {
            dropDown
                .addOption(Location[Location.VaultFolder], 'Vault folder')
                .addOption(Location[Location.SameFolder], 'Same folder as current file')
                .addOption(Location[Location.SpecifiedFolder], 'In the folder specified below')
                .setValue(Location[this.plugin.settings.newFileLocation] ||
                Location[Location.VaultFolder])
                .onChange((value) => __awaiter(this, void 0, void 0, function* () {
                this.plugin.settings.newFileLocation =
                    Location[value];
                yield this.plugin.saveSettings();
                this.display();
            }));
        });
        if (this.plugin.settings.newFileLocation == Location.SpecifiedFolder) {
            new obsidian.Setting(containerEl)
                .setName('Folder to create new canvas files in')
                .addText((text) => {
                text
                    .setPlaceholder('Example: folder 1/folder 2')
                    .setValue(this.plugin.settings.customFileLocation)
                    .onChange((value) => __awaiter(this, void 0, void 0, function* () {
                    this.plugin.settings.customFileLocation = value;
                    yield this.plugin.saveSettings();
                }));
            });
        }
    }
}

class LinkExploderPlugin extends obsidian.Plugin {
    onload() {
        return __awaiter(this, void 0, void 0, function* () {
            log.setUp(this);
            log.info(`${this.manifest.name} Loaded`);
            yield this.loadSettings();
            this.addSettingTab(new LinkExploderPluginSettingTab(this.app, this));
            this.addCommand({
                id: 'link-exploder-canvas-builder',
                name: 'Create Canvas From File Links',
                checkCallback: (checking) => {
                    if (checking) {
                        return true;
                    }
                    const activeFile = this.app.workspace.getActiveFile();
                    if (activeFile) {
                        const doesFileExist = (path) => Boolean(this.app.vault.getAbstractFileByPath(path));
                        const createFile = (path, data) => this.app.vault.create(path, data);
                        const openFile = (currentFile) => this.app.workspace.getLeaf().openFile(currentFile);
                        activeFile.parent;
                        let location = '';
                        switch (this.settings.newFileLocation) {
                            case Location.SameFolder:
                                location = activeFile.parent.path;
                                break;
                            case Location.SpecifiedFolder:
                                if (doesFileExist(this.settings.customFileLocation)) {
                                    location = this.settings.customFileLocation;
                                }
                                new obsidian.Notice(`folder ${this.settings.customFileLocation} does not exist, creating in root folder`);
                        }
                        createCanvasFromFile(activeFile, this.app.metadataCache.resolvedLinks, doesFileExist, createFile, openFile, location).catch((e) => {
                            new obsidian.Notice(`Something went wrong with creating the canvas: ${e}`);
                            console.error(e);
                        });
                    }
                },
            });
            // this only appears if in dev mode, allows quick reloading with shift-cmd-R
            if (this.manifest.name.contains('Canary')) {
                this.addCommand({
                    id: 'reloadLinkExploder',
                    name: 'Reload LinkExploder (dev)',
                    callback: () => {
                        const id = this.manifest.id;
                        // @ts-ignore - for this.app.plugins
                        const plugins = this.app.plugins;
                        plugins.disablePlugin(id).then(() => plugins.enablePlugin(id));
                        new obsidian.Notice('Reloading LinkExploder');
                    },
                    hotkeys: [{ key: 'r', modifiers: ['Mod', 'Shift'] }],
                });
            }
        });
    }
    loadSettings() {
        return __awaiter(this, void 0, void 0, function* () {
            this.settings = Object.assign({}, yield this.loadData());
        });
    }
    saveSettings() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.saveData(this.settings);
        });
    }
    onunload() {
        log.info('unloading link exploder');
    }
}

module.exports = LinkExploderPlugin;


/* nosourcemap */